##
#
# This file contains auxilary methods to quickly create and configure ByteBlower
# ports and flow configurations, which are the two building blocks of the
# ByteBlowerHL API.
#
# This file will typically be included in the proc file of an example. This way,
# shared procedures do not always need to be copied.
#
# Finally, this file loads the three Tcl packages required by the example
# scripts.
#
# By using these methods to create ports and flows and passing
# those as input to the higher-layer, many scenarios can be created very in a
# simple way.
#
# This file was build to support the ByteBlower higher-layer example scripts.
# In a similar way, you can create shared 'library' files with support methods
# like these.
#
##

package require ByteBlower
package require excentis_basic
package require ByteBlowerHL

namespace eval excentis {
namespace eval ByteBlower {
namespace eval Examples {

    ##
    # This will add a Layer2.5 VLAN configuration to a ByteBlower port.
    #
    # @param id
    #           The VLAN ID (value 2 to 4095)
    # @param priority
    #           The default VLAN priority for this port (value 0 to 7)
    # @param dropeligible
    #           Flag included in the VLAN tag on every packet, indicating
    #           whether it is eligible for drop.
    # @return
    #           The Layer2.5 object which was added to the port.
    #
    proc Setup.Port.Layer2_5.Vlan { port id {priority ""} {dropeligible ""} } {
        set L25Vlan [ $port Layer2_5.Vlan.Add ]

        $L25Vlan ID.Set $id
        if { ! [string equal $priority ""] } {
            $L25Vlan Priority.Set $priority
        }
        if { ! [string equal $dropeligible ""] } {
            $L25Vlan DropEligible.Set $dropeligible
        }

        return $L25Vlan
    }

    ##
    # This will setup a ByteBlower port with a Layer3 configuration.
    #
    # @param ipAddress
    #           The fixed IP address or an address retrieval method:
    #            - an IPv4 address
    #            - an IPv6 address
    #            - dhcpv4 DHCPv4 will be used to retrieve an address.
    #            - dhcpv6 DHCPv6 will be used to retrieve an address.
    #            - stateless Stateless autoconfiguration will be used to
    #              retrieve an address.
    # @param gateway
    #           The default gateway for the subnet (IPv4 and IPv6). Only use
    #           for fixed addresses, not for dhcp or stateless autoconf.
    # @param netmask
    #           The netmask of the IP subnet (IPv4 only). Only use for fixed
    #           IP addresses, not for dhcp.
    # @param gratuitousArp
    #           The method of running the announcing Gratuitous ARP (GARP).
    #           Possible values are none, request, reply
    # @return
    #           The Layer3 object which is created on the port.
    #
    proc Setup.Port.Layer3 { port ipAddress { gateway "null" }  {  netmask "null" } { gratuitousArp "reply" } } {
        # fixed IPv4 case
        if { [string first "." $ipAddress ]  != -1 } {
            set ret [ x.Setup.Port.Layer3.IPv4.Static $port $ipAddress $gateway $netmask ]
            x.Setup.Port.GArp $port $gratuitousArp
            return $ret
        }
        # fixed IPv6 case
        if { [string first ":" $ipAddress ] != -1 } {
            return [ x.Setup.Port.Layer3.IPv6.Static $port $ipAddress $gateway ]
        }
        # autogenerated case
        switch -exact -- $ipAddress {
            dhcpv4 {
                set ret [ x.Setup.Port.Layer3.IPv4.Dhcp $port ]
                x.Setup.Port.GArp $port $gratuitousArp
                return $ret
            }
            dhcpv6 {
                return [ x.Setup.Port.Layer3.IPv6.Dhcp $port ]
            }
            stateless {
                return [ x.Setup.Port.Layer3.IPv6.Stateless $port ]
            }
            default {
                error "Unknown address configuration \"$ipAddress\""
            }
        }
    }
    
    proc x.Setup.Port.GArp { port type } {
        switch -- [ string tolower $type ] {
            "request" {
                [ $port Layer3.IPv4.Get ] Protocol.GratuitousArp.Request
            }
            "reply" {
                [ $port Layer3.IPv4.Get ] Protocol.GratuitousArp.Request
            }
            "none" {
                # Do nothing
            }
            default {
                error "Unknown Gratuitous ARP type: '$type'.  Must be one of 'none','request','reply'"
            }
        }
    }

    proc x.Setup.Port.Layer3.IPv4.Dhcp { port } {
        set L3 [ $port Layer3.IPv4.Set ]
        [ $L3 Protocol.Dhcp.Get ] Perform
        return $L3
    }

    proc x.Setup.Port.Layer3.IPv4.Static { port ipAddress gateway netmask } {
        set L3 [ $port Layer3.IPv4.Set ]
        $L3 Ip.Set $ipAddress
        $L3 Gateway.Set $gateway
        $L3 Netmask.Set $netmask
        return $L3
    }

    proc x.Setup.Port.Layer3.IPv6.Static { port ipAddress gateway } {
        set L3 [ $port Layer3.IPv6.Set ]
        $L3 Ip.Manual.Add $ipAddress
        if { ![string equal $gateway "null"] } {
            #$L3 Gateway.Set $gateway
        }
        return $L3
    }

    proc x.Setup.Port.Layer3.IPv6.Dhcp { port } {
        set L3 [ $port Layer3.IPv6.Set ]
        [ $L3 Protocol.Dhcp.Get ] Perform
        return $L3
    }

    proc x.Setup.Port.Layer3.IPv6.Stateless { port } {
        set L3 [ $port Layer3.IPv6.Set ]
        $L3 StatelessAutoconfiguration
        return $L3
    }

    ##
    # This method will return the IPv6 address based on the same parameters
    # provided to the Setup.Port.Layer3 procedure.
    #
    # @param ipAddress
    #           The parameter has the same semantics as the Setup.Port.Layer3
    #           procedure. An IPv6 ports may have multiple address types. By
    #           passing the correct L3 configuration code (e.g. dhcpv6) that
    #           specific address can be retrieved.
    # @return
    #           The requested IPv4 or IPv6 address on this port.
    #
    proc Setup.Port.Layer3.Get { port args } {
        if { ![ $port Info -implements ByteBlowerPort ] } {
            error "Port $port is not a ByteBlowerPort!"
        }
        set ipAddress [ lindex $args 0 ]
        # fixed IPv4 case
        if { [string first "." $ipAddress ]  != -1 } {
            return [ [ $port Layer3.IPv4.Get ] Ip.Get ]
        }
        # fixed IPv6 case
        if { [string first ":" $ipAddress ] != -1 } {
            return [ [ $port Layer3.IPv6.Get ] Ip.Manual.Get ]
        }
        # auto-generated case
        switch -exact -- $ipAddress {
            dhcpv4 {
                return [ [ $port Layer3.IPv4.Get ] Ip.Get ]
            }
            dhcpv6 {
                return [ [ $port Layer3.IPv6.Get ] Ip.Dhcp.Get ]
            }
            stateless {
                return [ [ $port Layer3.IPv6.Get ] Ip.Stateless.Get ]
            }
            default {
                error "Unknown address configuration \"$ipAddress\""
            }
        }
    }
    
    proc Setup.WirelessEndpoint.Layer3.Get { port args } {
        if { ![ $port Info -implements WirelessEndpoint ] } {
            error "Port $port is not a WirelessEndpoint!"
        }
        set ipAddress [ lindex $args 0 ]
        set device_info [ $port Device.Info.Get ]
        set net_info [ $device_info Network.Info.Get ]
        
        # fixed IPv4 case
        if { [string first "." $ipAddress ]  != -1 || $ipAddress == "dhcpv4" } {
            return [ lindex [ $net_info IPv4.Get ] 0 ]
        }
        # fixed IPv6 case
        if { [string first ":" $ipAddress ] != -1 || $ipAddress == "dhcpv6" || $ipAddress == "stateless" } {
            return [ lindex [ $net_info IPv6.Global.Get ] 0 ]
        }

        error "Unknown address configuration \"$ipAddress\""

    }
    
    ##
    # This procedure generates a ByteBlowerHL flow configuration for a
    # back-2-back UDP over IPv4 flow between two ByteBlower ports. All
    # necessary data is provided as parameters.
    #
    # A basic trigger is used as RX part, unless latency, outofsequence or both
    # are specified.
    #
    # @param srcPort
    #           The ByteBlower port that sends the traffic.
    # @param dstPort
    #           The ByteBlower port that receives the traffic.
    # @param ethernetLength
    #           Length of the ethernet packet send in the flow (without CRC).
    # @param srcUdpPort
    #           The UDP source port used in the frame.
    # @param dstUdpPort
    #           The UDP destination port used in the frame.
    # @param numberOfFrames
    #           The number of frames sent in the flow.
    # @param interFrameGap
    #           The gap in nanoseconds between sending two consecutive frames in
    #           the flow.
    # @param latency
    #           A boolean stating whether latency measurement on the flow is
    #           enabled.If neither latency or outofsequence is used, a basic
    #           trigger is stored in the RX side.
    #           @default 0 (false)
    # @param outofsequence
    #           A boolean stating whether latency measurement on the flow is
    #           enabled. If neither latency or outofsequence is used, a basic
    #           trigger is stored in the RX side.
    #           @default 0 (false)
    # @return
    #           The flow configuration as requested by ByteBlowerHL functions.
    #           The flow construct consist of structured and nested lists,
    #           describing the setup of this flow.
    #
    proc Setup.Flow.IPv4.UDP { srcPort dstPort ethernetLength srcUdpPort destUdpPort numberOfFrames interFrameGap {latency 0} {outofsequence 0} } {
        set wirelessUpstream 0
        set wirelessDownstream 0
        
        if { [ $srcPort Info -implements WirelessEndpoint ] } {
            set wirelessUpstream 1
            set srcIp [ [ [ $srcPort Device.Info.Get ] Network.Info.Get ] IPv4.Get ]
        } else {
            set srcIp [ [ $srcPort Layer3.IPv4.Get ] Ip.Get ]
        }
        
        if { [ $dstPort Info -implements WirelessEndpoint ] } {
            set wirelessDownstream 1
            set dstIp [ [ [ $dstPort Device.Info.Get ] Network.Info.Get ] IPv4.Get ]
        } else {
            set dstIp [ [ $dstPort Layer3.IPv4.Get ] Ip.Get ]
        }

        set udpDataLength [ expr $ethernetLength - 42 ]
        
        
        if { ! $wirelessUpstream } {
            # Port configurations
            set srcL2 [ $srcPort Layer2.EthII.Get ]

            set srcL3 [ $srcPort Layer3.IPv4.Get ]

            
            if { ! $wirelessDownstream } {
                set dstL2 [ $dstPort Layer2.EthII.Get ]
                set dstL3 [ $dstPort Layer3.IPv4.Get ]
                set dstIp [ $dstL3 Ip.Get ]
            } else {
                set dstIp [ [ [ $dstPort Device.Info.Get ] Network.Info.Get ] IPv4.Get ]
            }

            # Get the destination MAC addresses to reach the other port
            set dmacSource [ $srcL3 Resolve $dstIp ]

            # Create the (UDP) scouting frame, leaving the IP and ethernet settings to default
            set scoutingFramePayload "BYTEBLOWER SCOUTING FRAME"
            if { [ binary scan $scoutingFramePayload H* scoutingFramePayloadHex ] != 1 } {
                error "UDP flow setup error: Unable to generate ByteBlower scouting frame payload."
            }
            set scoutingFramePayloadData [ ::excentis::basic::String.To.Hex $scoutingFramePayloadHex ]
            set srcScoutingFrame1 [ ::excentis::basic::Frame.Udp.Set $dmacSource [ $srcL2 Mac.Get ] $dstIp $srcIp $destUdpPort $srcUdpPort $scoutingFramePayloadData ]
            
            # Create the UDP frames, leaving the IP and ethernet settings to default

            set srcFrame1 [ ::excentis::basic::Frame.Udp.Set $dmacSource [ $srcL2 Mac.Get ] $dstIp $srcIp $destUdpPort $srcUdpPort [ list -Length $udpDataLength ] ]

            # Insert the source Layer2.5 tags (from inside out)
            set srcL25List [ $srcPort Layer2_5.Vlan.Get ]
            for { set i [expr [llength $srcL25List] - 1] } { $i >= 0 } { incr i -1 } {
                set srcL25 [lindex $srcL25List $i]
                set srcScoutingFrame1 [ ::excentis::basic::Frame.Vlan.Insert $srcScoutingFrame1 [ $srcL25 ID.Get ] [ $srcL25 Priority.Get ] [ $srcL25 DropEligible.Get ] ]
                set srcFrame1 [ ::excentis::basic::Frame.Vlan.Insert $srcFrame1 [ $srcL25 ID.Get ] [ $srcL25 Priority.Get ] [ $srcL25 DropEligible.Get ] ]
            }
        }

        if { ! $wirelessDownstream } {
            # Check the destination Layer2.5 tags
            set vlanFilters [ list ]
            set dstVlanCount 0
            set dstL25List [ $dstPort Layer2_5.Vlan.Get ]
            foreach dstL25 $dstL25List {
                lappend vlanFilters "vlan.id == [ $dstL25 ID.Get ]"
                incr dstVlanCount
            }


            # Create the filter
            if { $dstVlanCount > 0 } {
                set vlanFilter [ join $vlanFilters " and " ]
                set filter "$vlanFilter and (ip.src == $srcIp) and (ip.dst == $dstIp) and (eth.len == [expr $ethernetLength + 4 * $dstVlanCount])"
            } else {
                set filter "(ip.src == $srcIp) and (ip.dst == $dstIp) and (eth.len == $ethernetLength)"
            }
        }
        
        set txList [ list ]
        
        lappend txList -port $srcPort
        if { $wirelessUpstream == 0 } {
            set frameList [ list -bytes $srcFrame1 ]
            if { $wirelessDownstream } {
                lappend frameList -l4autochecksum 1
                lappend frameList -l3autochecksum 1
            }
            lappend txList -scoutingframe [ list -bytes $srcScoutingFrame1 ]
            lappend txList -frame $frameList
        } else {
            set payload ""
            while { [ llength $payload ] < $udpDataLength } {
                lappend payload 0xdd
            }
        
            lappend txList -frame [ list \
                -payload $payload \
                -sourcePort $srcUdpPort \
                -destinationPort $destUdpPort \
                -destinationAddress $dstIp \
            ]

        }
        lappend txList -numberofframes $numberOfFrames
        lappend txList -interframegap $interFrameGap 
        if { $latency } {
            lappend txList -latency 1
        }
        if { $outofsequence } {
            lappend txList -outofsequence 1
        }
        
        set rxFilter [ list ]
        if { $wirelessDownstream == 0 } {
            lappend rxFilter -filter $filter
        } else {
            lappend rxFilter -filterFormat tuple
            lappend rxFilter -filter [ list \
                -sourceAddress $srcIp \
                -udpDestinationPort $destUdpPort \
                -udpSourcePort $srcUdpPort \
            ]
            set interFrameGap_ns [ Setup.ConvertDurationToNanoseconds $interFrameGap ]
            # We set the duration in ms because some 32-bit versions
            # of Tcl do not support this magnitude of integers.
            set duration_ms [ expr int(ceil((double($numberOfFrames) * double($interFrameGap_ns) / 1000000.0) + 1000.0)) ]
            lappend rxFilter -duration "${duration_ms}ms"
        }

        
        # Create the flow
        if { $latency && $outofsequence } {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -latency $rxFilter \
                                ] \
                            -rx [ list  -port $dstPort \
                                        -outofsequence $rxFilter \
                                ] \
                   ]
        } elseif { $latency } {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -latency $rxFilter \
                                ] \
                   ]
        } elseif { $outofsequence } {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -outofsequence $rxFilter \
                                ] \
                   ]
        } else {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -trigger $rxFilter \
                                ] \
                   ]
        }
        
        return $flow
    }

    ##
    # This procedure generates a ByteBlowerHL flow configuration for a
    # back-2-back UDP over IPv4 flow between two ByteBlower ports, where the
    # source port is behind a NAT device. Because of this, the sent frame will
    # be different from the received frame. All necessary data is provided as
    # parameters.
    #
    # A basic trigger is used as RX part, unless latency, outofsequence or both
    # are specified.
    #
    # @param srcPort
    #           The ByteBlower port that sends the traffic.
    # @param dstPort
    #           The ByteBlower port that receives the traffic.
    # @param ethernetLength
    #           Length of the ethernet packet send in the flow (without CRC).
    # @param publicSrcIP
    #           The public IP adress of the source port. This is the public NAT
    #           device address.
    # @param publicDstIP
    #           The (public) IP address of the destination port. This value
    #           should be the same as the normal IP address of the (public)
    #           destination port. It is not used.
    # @param publicSrcUdpPort
    #           The public IP address of the source port. This is the translated
    #           UDP port value on the NATbox for traffic comming from the
    #           @param srcPort with source UDP @param privateSrcUdpPort.
    # @param publicDstUdpPort
    #           The public UDP port of the destination. Because this port is
    #           outside the NAT domain, this will always be correct.
    # @param privateSrcUdpPort
    #           The private UDP port  of the source port. This is the port that
    #           will be translated by the NATbox.
    # @param privateDstUdpPort
    #           The (private) UDP port of the destination port. Because it is
    #           the public port, this parameter makes no sense. It should be the
    #           same as the @param publicDstUdpPort value. It is not used.
    # @param numberOfFrames
    #           The number of frames sent in the flow.
    # @param interFrameGap
    #           The gap in nanoseconds between sending two consecutive frames in
    #           the flow.
    # @param latency
    #           A boolean stating whether latency measurement on the flow is
    #           enabled. If neither latency or outofsequence is used, a basic
    #           trigger is stored in the RX side.
    #           @default 0 (false)
    # @param outofsequence
    #           A boolean stating whether latency measurement on the flow is
    #           enabled. If neither latency or outofsequence is used, a basic
    #           trigger is stored in the RX side.
    #           @default 0 (false)
    # @return
    #           The flow configuration as requested by ByteBlowerHL functions.
    #           The flow construct consist of structured and nested lists,
    #           describing the setup of this flow.
    #
    proc Setup.Flow.IPv4.UDP.NAT { srcPort dstPort ethernetLength publicSrcIP publicDstIP publicSrcUdpPort publicDstUdpPort privateSrcUdpPort privateDstUdpPort numberOfFrames interFrameGap  {latency 0} {outofsequence 0} } {
        # Port configurations
        
        if { ![ $srcPort Info -implements WirelessEndpoint ] } {
            set srcL2 [ $srcPort Layer2.EthII.Get ]
            set srcMac [ $srcL2 Mac.Get ]
            set srcL3 [ $srcPort Layer3.IPv4.Get ]
            set srcIp [ $srcL3 Ip.Get ]
        } else {
            set srcIp [ [ [ $srcPort Device.Info.Get ] Network.Info.Get ] IPv4.Get ]
        }
        
        if { ![ $dstPort Info -implements WirelessEndpoint ] } {
            set dstL2 [ $dstPort Layer2.EthII.Get ]
            set dstMac [ $dstL2 Mac.Get ]
            set dstL3 [ $dstPort Layer3.IPv4.Get ]
            set dstIp [ $dstL3 Ip.Get ]
        } else {
            set dstIp [ [ [ $dstPort Device.Info.Get ] Network.Info.Get ] IPv4.Get ]
        }
        
        # If we are sending from a public port to a natted port, we need to send 
        # to the public IP address
        set triggerDstIp $dstIp
        if { $dstIp != $publicDstIP } {
        	set dstIp $publicDstIP
        }
        
        set udpDataLength [ expr $ethernetLength - 42 ]
        set txList [ list ]
        lappend txList -port $srcPort
        
        if { ! [ $srcPort Info -implements WirelessEndpoint ] } {
            # Get the destination MAC addresses to reach the other port
            set dmacSource [ $srcL3 Resolve $dstIp ]
        
            # Create the (UDP) scouting frame, leaving the IP and ethernet settings to default
            set scoutingFramePayload "BYTEBLOWER SCOUTING FRAME"
            if { [ binary scan $scoutingFramePayload H* scoutingFramePayloadHex ] != 1 } {
                error "UDP flow setup error: Unable to generate ByteBlower scouting frame payload."
            }
            set scoutingFramePayloadData [ ::excentis::basic::String.To.Hex $scoutingFramePayloadHex ]
            set srcScoutingFrame1 [ ::excentis::basic::Frame.Udp.Set $dmacSource [ $srcL2 Mac.Get ] $dstIp $srcIp $publicDstUdpPort $privateSrcUdpPort $scoutingFramePayloadData ]
            
            lappend txList -scoutingframe [ list -bytes $srcScoutingFrame1 ]
            
            # Create the UDP frames, leaving the IP and ethernet settings to default
            set srcFrame1 [ ::excentis::basic::Frame.Udp.Set $dmacSource [ $srcL2 Mac.Get ] $dstIp $srcIp $publicDstUdpPort $privateSrcUdpPort [ list -Length $udpDataLength ] ]

            # Insert the source Layer2.5 tags (from inside out)
            set srcL25List [ $srcPort Layer2_5.Vlan.Get ]
            for { set i [expr [llength $srcL25List] - 1] } { $i >= 0 } { incr i -1 } {
                set srcL25 [lindex $srcL25List $i]
                set srcScoutingFrame1 [ ::excentis::basic::Frame.Vlan.Insert $srcScoutingFrame1 [ $srcL25 ID.Get ] [ $srcL25 Priority.Get ] [ $srcL25 DropEligible.Get ] ]
                set srcFrame1 [ ::excentis::basic::Frame.Vlan.Insert $srcFrame1 [ $srcL25 ID.Get ] [ $srcL25 Priority.Get ] [ $srcL25 DropEligible.Get ] ]
            }
            
            set frameList [ list ]
            lappend frameList -bytes $srcFrame1
            if { [ $dstPort Info -implements WirelessEndpoint ] } {
                lappend frameList -l4autochecksum 1
                lappend frameList -l3autochecksum 1
            }
            lappend txList -frame $frameList
            
            
            
        } else {
            set payload ""
            while { [ llength $payload ] < $udpDataLength } {
                lappend payload 0xdd
            }
        
            lappend txList -frame [ list \
                -payload $payload \
                -sourcePort $privateSrcUdpPort \
                -destinationPort $publicDstUdpPort \
                -destinationAddress $dstIp \
            ]

        }
        lappend txList -numberofframes $numberOfFrames\
                       -interframegap $interFrameGap

        if { $latency } {
            lappend txList -latency 1
        }
        if { $outofsequence } {
            lappend txList -outofsequence 1
        }
        



        # Check the destination Layer2.5 tags
        set vlanFilters [ list ]
        set dstVlanCount 0
        set filterList [ list ]
        if { ! [$dstPort Info -implements WirelessEndpoint ] } {
            set dstL25List [ $dstPort Layer2_5.Vlan.Get ]
            foreach dstL25 $dstL25List {
                lappend vlanFilters "vlan.id == [ $dstL25 ID.Get ]"
                incr dstVlanCount
            }
            
            # Create the filter
            if { $dstVlanCount > 0 } {
                set vlanFilter [ join $vlanFilters " and " ]
                set filter "$vlanFilter and (ip.src == $publicSrcIP) and (ip.dst == $triggerDstIp) and (eth.len == [expr $ethernetLength + 4 * $dstVlanCount])"
            } else {
            	set filter "(ip.src == $publicSrcIP) and (ip.dst == $triggerDstIp) and (eth.len == $ethernetLength)"
            }
            lappend filterList -filter $filter 
        } else {
            lappend filterList -filterFormat tuple
            lappend filterList -filter [ list \
                -sourceAddress $publicSrcIP \
                -udpDestinationPort $privateDstUdpPort \
                -udpSourcePort $privateSrcUdpPort \
            ]
            
            set interFrameGap_ns [ Setup.ConvertDurationToNanoseconds $interFrameGap ]
            
            # We set the duration in ms because some 32-bit versions
            # of Tcl do not support this magnitude of integers.
            set duration_ms [ expr int(ceil((double($numberOfFrames) * double($interFrameGap_ns) / 1000000.0) + 1000.0)) ]
            lappend filterList -duration "${duration_ms}ms"
        }



        # Create the flow
        if { $latency && $outofsequence } {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -latency $filterList \
                                ] \
                            -rx [ list  -port $dstPort \
                                        -outofsequence $filterList \
                                ] \
                     ]
        } elseif { $latency } {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -latency $filterList \
                                ] \
                     ]
        } elseif { $outofsequence } {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -outofsequence $filterList \
                                ] \
                     ]
        } else {
            set flow [ list -tx $txList \
                            -rx [ list  -port $dstPort \
                                        -trigger $filterList \
                                ] \
                     ]
        }
        puts "Created Flow: $flow"
        return $flow
    }

    ##
    # This procedure generates a ByteBlowerHL flow configuration for a
    # back-2-back UDP over IPv6 flow between two ByteBlower ports. All
    # necessary data is provided as parameters.
    #
    # A basic trigger is used as RX part, unless latency, outofsequence or both
    # are specified.
    #
    # @param srcPort
    #           The ByteBlower port that sends the traffic.
    # @param srcIP
    #           The actual source IP address used. Because IPv6 ports may have
    #           multiple addresses, we specify it here.
    # @param dstPort
    #           The ByteBlower port that receives the traffic.
    # @param dstIP
    #           The actual destination IP address used. Because IPv6 ports may
    #           have multiple addresses, we specify it here.
    # @param ethernetLength
    #           Length of the ethernet packet send in the flow (without CRC).
    # @param srcUdpPort
    #           The UDP source port used in the frame.
    # @param dstUdpPort
    #           The UDP destination port used in the frame.
    # @param numberOfFrames
    #           The number of frames sent in the flow.
    # @param interFrameGap
    #           The gap in nanoseconds between sending two consecutive frames in
    #           the flow.
    # @param latency
    #           A boolean stating whether latency measurement on the flow is
    #           enabled. If neither latency or outofsequence is used, a basic
    #           trigger is stored in the RX side.
    #           @default 0 (false)
    # @param outofsequence
    #           A boolean stating whether latency measurement on the flow is
    #           enabled. If neither latency or outofsequence is used, a basic
    #           trigger is stored in the RX side.
    #           @default 0 (false)
    # @return
    #           The flow configuration as requested by ByteBlowerHL functions.
    #           The flow construct consist of structured and nested lists,
    #           describing the setup of this flow.
    #
    proc Setup.Flow.IPv6.UDP { srcPort srcIP dstPort dstIP ethernetLength srcUdpPort destUdpPort numberOfFrames interFrameGap {latency 0} {outofsequence 0} } {
        # Port configurations

        if { [ $srcPort Info -implements ByteBlowerPort ] } {
            set srcL2 [ $srcPort Layer2.EthII.Get ]
            set srcL3 [ $srcPort Layer3.IPv6.Get ]            
        }

        
        # Create the (UDP) scouting frame, leaving the IP and ethernet settings to default
        set scoutingFramePayload "BYTEBLOWER SCOUTING FRAME"
        if { [ binary scan $scoutingFramePayload H* scoutingFramePayloadHex ] != 1 } {
            error "UDP flow setup error: Unable to generate ByteBlower scouting frame payload."
        }
        set scoutingFramePayloadData [ ::excentis::basic::String.To.Hex $scoutingFramePayloadHex ]
        
        set udpDataLength [ expr $ethernetLength - 62 ]

        if { [ $srcPort Info -implements ByteBlowerPort ] } {
            # Get the destination MAC addresses to reach the other port
            set dmacSource [ $srcL3 Resolve $dstIP ]
            set srcScoutingFrame1 [ ::excentis::basic::Frame.Udpv6.Set $dmacSource [ $srcL2 Mac.Get ] $dstIP $srcIP $destUdpPort $srcUdpPort $scoutingFramePayloadData ]
            set txScoutingFrameList [ list -bytes $srcScoutingFrame1 ]

            # Create the UDP frames, leaving the IP and ethernet settings to default
            
            set srcFrame1 [ ::excentis::basic::Frame.Udpv6.Set $dmacSource [ $srcL2 Mac.Get ] $dstIP $srcIP $destUdpPort $srcUdpPort [ list -Length $udpDataLength ] ]

            # Insert the source Layer2.5 tags (from inside out)
            set srcL25List [ $srcPort Layer2_5.Vlan.Get ]
            for { set i [expr [llength $srcL25List] - 1] } { $i >= 0 } { incr i -1 } {
                set srcL25 [lindex $srcL25List $i]
                set srcScoutingFrame1 [ ::excentis::basic::Frame.Vlan.Insert $srcScoutingFrame1 [ $srcL25 ID.Get ] [ $srcL25 Priority.Get ] [ $srcL25 DropEligible.Get ] ]
                set srcFrame1 [ ::excentis::basic::Frame.Vlan.Insert $srcFrame1 [ $srcL25 ID.Get ] [ $srcL25 Priority.Get ] [ $srcL25 DropEligible.Get ] ]
            }
            
            set txFrameList [ list -bytes $srcFrame1 ]
        } elseif { [ $srcPort Info -implements WirelessEndpoint ] } {
            set txScoutingFrameList [ list ]     
            set payload [ string repeat "0xBB " $udpDataLength ]
            set txFrameList [ list \
                -payload $payload \
                -sourcePort $srcUdpPort \
                -destinationPort $destUdpPort \
                -destinationAddress $dstIP \
            ]
        }
        
        set txStreamList [ list \
            -port $srcPort \
            -frame $txFrameList \
            -numberofframes $numberOfFrames \
            -interframegap $interFrameGap]
            
        if { [ llength $txScoutingFrameList ] != 0 } {
            lappend txStreamList -scoutingframe $txScoutingFrameList
        }
        if { $latency } { 
            lappend txStreamList -latency 1
        }
        if { $outofsequence } {
            lappend txStreamList -outofsequence 1
        }

        set rxFilterList [ list ]
        if { [ $dstPort Info -implements ByteBlowerPort ] } {
            # Check the destination Layer2.5 tags
            set vlanFilters [ list ]
            set dstVlanCount 0
            set dstL25List [ $dstPort Layer2_5.Vlan.Get ]
            foreach dstL25 $dstL25List {
                lappend vlanFilters "vlan.id == [ $dstL25 ID.Get ]"
                incr dstVlanCount
            }

            # Create the filter
            if { $dstVlanCount > 0 } {
                set vlanFilter [ join $vlanFilters " and " ]
                set filter "$vlanFilter and (ipv6.src == $srcIP) and (ipv6.dst == $dstIP) and (eth.len == [expr $ethernetLength + 4 * $dstVlanCount])"
            } else {
                set filter "(ipv6.src == $srcIP) and (ipv6.dst == $dstIP) and (eth.len == $ethernetLength)"
            }
            lappend rxFilterList -filter $filter
        } elseif { [ $dstPort Info -implements WirelessEndpoint ] } {
            lappend rxFilterList -filterFormat tuple
            lappend rxFilterList -filter [ list \
                -sourceAddress $srcIP \
                -udpDestinationPort $destUdpPort \
                -udpSourcePort $srcUdpPort \
            ]
            
            set interFrameGap_ns [ Setup.ConvertDurationToNanoseconds $interFrameGap ]
            # We set the duration in ms because some 32-bit versions
            # of Tcl do not support this magnitude of integers.
            set duration_ms [ expr int(ceil((double($numberOfFrames) * double($interFrameGap_ns) / 1000000.0) + 1000.0)) ]
            lappend rxFilterList -duration "${duration_ms}ms"
        }
        

        # Create the flow
        if { $latency && $outofsequence } {
            return [ list   -tx $txStreamList \
                            -rx [ list  -port $dstPort \
                                        -latency $rxFilterList \
                                ] \
                            -rx [ list  -port $dstPort \
                                        -outofsequence $rxFilterList \
                                ] \
                   ]
        } elseif { $latency } {
            return [ list   -tx $txStreamList \
                            -rx [ list  -port $dstPort \
                                        -latency $rxFilterList \
                                ] \
                   ]
        } elseif { $outofsequence } {
            return [ list   -tx $txStreamList \
                            -rx [ list  -port $dstPort \
                                        -outofsequence $rxFilterList \
                                ] \
                   ]
        } else {
            return [ list   -tx $txStreamList \
                            -rx [ list  -port $dstPort \
                                        -trigger $rxFilterList \
                                ] \
                   ]
        }
    }

    proc RunScoutingFlowV4 { dstPort srcPort dstUdpPort srcUdpPort { numberOfFrames 1 } { interFrameGap 10000000 } { leadOutTime 100000000 } } {
       
        set srcIp [ [ $srcPort Layer3.IPv4.Get ] Ip.Get ]
        set dstIp [ [ $dstPort Layer3.IPv4.Get ] Ip.Get ]
        
        set srcMac [ [ $srcPort Layer2.EthII.Get ] Mac.Get ]
        set dstMac [ [ $srcPort Layer3.IPv4.Get ] Resolve $dstIp ]
        
        set scoutingFramePayload "BYTEBLOWER SCOUTING FRAME"
        if { [ binary scan $scoutingFramePayload H* scoutingFramePayloadHex ] != 1 } {
            error "UDP flow setup error: Unable to generate ByteBlower scouting frame payload."
        }
        set scoutingFramePayloadData [ ::excentis::basic::String.To.Hex $scoutingFramePayloadHex ]
        set scoutingFrame [ ::excentis::basic::Frame.Udp.Set $dstMac $srcMac \
            $dstIp $srcIp $dstUdpPort $srcUdpPort $scoutingFramePayloadData ]
            
        # Add the VLANs of the src port to the the frame
        set l2_5 [ $srcPort Layer2_5.Vlan.Get ]
        set i [ llength $l2_5 ]
        while { $i > 0 } {
            set l25 [ lindex $l2_5 [ incr i -1 ] ]
            set scoutingFrame [ ::excentis::basic::Frame.Vlan.Insert $scoutingFrame \
                [ $l25 ID.Get ] [ $l25 Priority.Get ] [ $l25 DropEligible.Get ] ]
        }

        set stream [ $srcPort Tx.Stream.Add ]
        [ $stream Frame.Add ] Bytes.Set $scoutingFrame
        $stream NumberOfFrames.Set $numberOfFrames
        $stream InterFrameGap.Set "${interFrameGap}ns"
        
        set trigger [ $dstPort Rx.Trigger.Basic.Add ]
        $trigger Filter.Set "ip src $srcIp and ip dst $dstIp and udp port $srcUdpPort and udp port $dstUdpPort"
        
        # calculate total scouting stream duration in milliseconds
        set duration [ expr int(ceil( ( [ $stream InitialTimeToWait.Get ] / 1e6 ) + ( [ $stream InterFrameGap.Get ] / 1e6 * [ $stream NumberOfFrames.Get ] ) + ( $leadOutTime / 1e6 ))) ]
        $stream Start
        
        set ::scouting_stop 0
        after $duration { set ::scouting_stop 1 }
        vwait ::scouting_stop
        
        $stream Stop
        
        set streamResult [ $stream Result.Get ]
        $streamResult Refresh
        set triggerResult [ $trigger Result.Get ]
        $triggerResult Refresh
        
        set streamFrames [ $streamResult PacketCount.Get ]
        set triggerFrames [ $triggerResult PacketCount.Get ]
                
        $stream Destructor
        $trigger Destructor
        
        return [ list $streamFrames $triggerFrames ]
    }
    
    proc Setup.ConvertDurationToNanoseconds { duration } {
        if { [ string range $duration end-1 end ] == "ns" } {
            return "[string range $duration 0 end-2]"
        }
        
        if { [ string range $duration end-1 end ] == "us" } {
            return "[string range $duration 0 end-2]000"
        }

        if { [ string range $duration end-1 end ] == "ms" } {
            return "[string range $duration 0 end-2]000000"
        }
        
        if { [ string range $duration end end ] == "s" } {
            return "[string range $duration 0 end-1]000000000"
        }
        

        return $duration
    }

}
}
}
